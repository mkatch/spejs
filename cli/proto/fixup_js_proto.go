package proto

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

var invocationTime = time.Now().Format("2006-01-02 15:04:05 -0700")
var workingDir, _ = os.Getwd()

var generatedHeader = strings.Join([]string{
	fmt.Sprintf("// Generated file. DO NOT EDIT.\n"), //lint:ignore S1039 for symmetry
	fmt.Sprintf("// Time: %s\n", invocationTime),
	fmt.Sprintf("// Command: %s\n", strings.Join(os.Args, " ")),
	fmt.Sprintf("// Working directory: %s\n\n", workingDir),
}, "")
var transfomedHeader = strings.Join([]string{
	"// This file has been first generated by protoc with --js_out=import_style=browser (at least it should have been).\n",
	"// Then it was transformed with fixup-js-proto. Lines annotated with `// fixup` were added or altered from the original\n\n",
}, "")

func FixupJsProto(args []string) (err error) {
	f := flag.NewFlagSet("FixupProtoJs", flag.ExitOnError)
	var (
		inputFlag       = f.String("input", "", "The input .proto file used to generate the intermediate .js/.ts files.")
		internalDirFlag = f.String("internal-dir", "", "The internal directory hosting the generated intermediate .js/.ts files.")
		outDirFlag      = f.String("out-dir", "", "The output directory for the final bundle .ts file.")
	)
	f.Parse(args)
	if *inputFlag == "" {
		return nil // Skipping if nothing to do
	}
	if *outDirFlag == "" {
		return fmt.Errorf("output directory required")
	}
	if *internalDirFlag == "" {
		return fmt.Errorf("internal directory required")
	}

	protoPath, err := filepath.Abs(*inputFlag)
	if err != nil {
		return err
	}
	protoBase := filepath.Base(protoPath)
	protoStem := strings.TrimSuffix(protoBase, ".proto")
	if protoBase != protoStem+".proto" {
		return fmt.Errorf("input file name must have \".proto\" extension, got: %s", protoBase)
	}

	internalDir, err := filepath.Abs(*internalDirFlag)
	if err != nil {
		return err
	}

	outDir, err := filepath.Abs(*outDirFlag)
	if err != nil {
		return err
	}
	// outPath := filepath.Join(outDir, stem+".ts")

	// internalDir := filepath.Join(outDir, "internal")
	// if err := os.Mkdir(internalDir, os.ModePerm); err != nil && !errors.Is(err, fs.ErrExist) {
	// 	return fmt.Errorf("unable to create internal directory %s: %w", internalDir, err)
	// }

	messageJsPath := filepath.Join(internalDir, protoStem+"_pb.js")
	err = transformJsMessageFile(messageJsPath)
	if err != nil {
		return err
	}

	serviceNames, err := collectServiceNames(protoPath)
	if err != nil {
		return err
	}

	err = createLibTsFile(outDir, internalDir, protoStem, serviceNames)
	if err != nil {
		return err
	}

	// outFile, err := os.Create(outPath)
	// if err != nil {
	// 	return fmt.Errorf("unable to create output file %s: %w", outPath, err)
	// }
	// defer outFile.Close()
	// out := bufio.NewWriter(outFile)
	// defer out.Flush()

	// fmt.Fprintf(out, "// Generated file. DO NOT EDIT.\n")
	// fmt.Fprintf(out, "// Time: %s\n", invocationTime)
	// fmt.Fprintf(out, "// Command: %s\n", strings.Join(os.Args, " "))
	// fmt.Fprintf(out, "// Working directory: %s\n\n", workingDir)

	// fmt.Fprintf(out, "export * from './internal/%s_pb';\n", stem)

	// for _, service := range serviceNames {
	// 	err := transformClientPbTs(outDir, internalDir, service)
	// 	if err != nil {
	// 		return err
	// 	}
	// 	fmt.Fprintf(out, "export * from './internal/%sClientPb';\n", service)
	// }

	return nil
}

func transformJsMessageFile(path string) error {
	exportPat, err := regexp.Compile(`goog.exportSymbol\('([^']*)'`)
	if err != nil {
		return err
	}

	origPath := path + ".orig"
	if err := os.Rename(path, origPath); err != nil {
		return err
	}
	origFile, err := os.Open(origPath)
	if err != nil {
		return err
	}
	defer origFile.Close()
	in := bufio.NewScanner(origFile)

	outFile, err := os.Create(path)
	if err != nil {
		return err
	}
	defer outFile.Close()
	out := bufio.NewWriter(outFile)
	defer out.Flush()

	out.WriteString(`
import * as jspb from 'google-protobuf';

window.global ??= {}
const proto = window.global.proto ??= {}
const goog = jspb;

`)

	var symbols []string
	for in.Scan() {
		line := in.Text()
		m := exportPat.FindStringSubmatch(line)
		if m != nil {
			symbol := m[1]
			symbols = append(symbols, symbol)
		}
		out.WriteString(line)
		out.WriteString("\n")
	}

	// var symbols []string
	// err = func() error {
	// 	file, err := os.Open(path)
	// 	if err != nil {
	// 		return err
	// 	}
	// 	defer file.Close()
	// 	in := bufio.NewScanner(file)

	// 	return nil
	// }()
	// if err != nil {
	// 	return err
	// }

	var ns string
	for _, sym := range symbols {
		if ns == "" {
			i := strings.LastIndex(sym, ".")
			if i > 0 {
				ns = sym[:i+1]
			} else {
				ns = sym
			}
		} else {
			for i := 0; i < len(sym) && i < len(ns); i++ {
				if sym[i] != ns[i] {
					ns = ns[:i]
					break
				}
			}
		}
	}

	// file, err := os.OpenFile(path, os.O_APPEND|os.O_WRONLY, os.ModeAppend)
	// if err != nil {
	// 	return err
	// }
	// defer file.Close()
	// out := bufio.NewWriter(file)
	// defer out.Flush()

	for _, sym := range symbols {
		trimmed := strings.TrimPrefix(sym, ns)
		if !strings.Contains(trimmed, ".") {
			fmt.Fprintf(out, "export const %s = %s;\n", trimmed, sym)
		}
	}

	return nil
}

func collectServiceNames(path string) (services []string, err error) {
	servicePat, err := regexp.Compile(`service ([^ ]+) {`)
	if err != nil {
		return nil, err
	}

	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	in := bufio.NewScanner(file)

	for in.Scan() {
		line := in.Text()
		service := servicePat.FindStringSubmatch(line)
		if service != nil {
			services = append(services, service[1])
		}
	}

	return services, nil
}

func createLibTsFile(outDir string, internalDir string, stem string, serviceNames []string) (err error) {
	libPath := filepath.Join(outDir, stem+".ts")
	libFile, err := os.Create(libPath)
	if err != nil {
		return err
	}
	defer libFile.Close()
	out := bufio.NewWriter(libFile)
	defer out.Flush()

	// 	out.WriteString(`
	// import * as jspb from 'google-protobuf'

	// if (!window.global) {
	// 	const proto = {}, goog = jspb
	// 	Object.assign(window, { global: { proto, goog: jspb }, proto, goog })
	// }

	// `)

	exports := []string{
		filepath.Join(internalDir, stem+"_pb"),
	}
	for _, service := range serviceNames {
		exports = append(exports, filepath.Join(internalDir, service+"ClientPb"))
	}

	for _, export := range exports {
		relExport, err := filepath.Rel(outDir, export)
		if err != nil {
			return err
		}
		relExport = strings.ReplaceAll(relExport, "\\", "/")
		relExport = path.Clean("./" + relExport)
		fmt.Fprintf(out, "export * from '%s'\n", relExport)
	}

	return nil
}

func transformPbJs1(outDir string, internalDir string, stem string) (err error) {
	base := stem + "_pb.js"
	inPath := filepath.Join(outDir, base)
	outPath := filepath.Join(internalDir, base)

	exportPat, err := regexp.Compile(`^(goog.exportSymbol\(')(proto\.)([^']+)(', null, )global(\);.*)$`)
	if err != nil {
		return err
	}
	var exportedSymbols []string

	err = renameTransformFile(inPath, outPath, func(in *bufio.Scanner, out *bufio.Writer) error {
		for in.Scan() {
			line := in.Text()
			m := exportPat.FindStringSubmatch(line)
			if m != nil {
				if len(exportedSymbols) == 0 {
					fmt.Fprint(out, "import * as jspb from 'google-protobuf'; // fixup\n")
					fmt.Fprint(out, "const goog = jspb; // fixup\n")
					fmt.Fprint(out, "const proto = {}; // fixup\n\n")
				}

				exportedSymbols = append(exportedSymbols, m[3])
				fmt.Fprintf(out, "%s%s%sproto%s // fixup\n", m[1], m[3], m[4], m[5])
			} else {
				out.WriteString(line)
				out.WriteString("\n")
			}
		}

		var ns string
		for _, sym := range exportedSymbols {
			if ns == "" {
				i := strings.LastIndex(sym, ".")
				if i > 0 {
					ns = sym[:i+1]
				} else {
					ns = sym
				}
			} else {
				for i := 0; i < len(sym) && i < len(ns); i++ {
					if sym[i] != ns[i] {
						ns = ns[:i]
						break
					}
				}
			}
		}

		for _, sym := range exportedSymbols {
			trimmed := strings.TrimPrefix(sym, ns)
			if !strings.Contains(trimmed, ".") {
				fmt.Fprintf(out, "export const %s = proto.%s; // fixup\n", trimmed, sym)
			}
		}

		return nil
	})

	if err != nil {
		return err
	}

	declBase := stem + "_pb.d.ts"
	inDeclPath := filepath.Join(outDir, declBase)
	outDeclTsPath := filepath.Join(internalDir, declBase)
	if err := os.Rename(inDeclPath, outDeclTsPath); err != nil {
		return fmt.Errorf("unable to move %s to %s: %w", inDeclPath, outDeclTsPath, err)
	}

	return nil
}

func transformClientPbTs(outDir string, internalDir string, service string) (err error) {
	base := service + "ClientPb.ts"
	inPath := filepath.Join(outDir, base)
	outPath := filepath.Join(internalDir, base)

	protoImportPat, err := regexp.Compile(`^(import[^']*')(\.[^']*/)([^/']+)('.*)$`)
	if err != nil {
		return err
	}

	return renameTransformFile(inPath, outPath, func(in *bufio.Scanner, out *bufio.Writer) error {
		for in.Scan() {
			line := in.Text()
			m := protoImportPat.FindStringSubmatch(line)
			if m != nil {
				fmt.Fprintf(out, "%s../%sinternal/%s%s //fixup\n", m[1], m[2], m[3], m[4])
			} else {
				out.WriteString(line)
				out.WriteString("\n")
			}
		}
		return nil
	})
}

func renameTransformFile(inPath string, outPath string, transform func(in *bufio.Scanner, out *bufio.Writer) error) (err error) {
	inFile, err := os.Open(inPath)
	if err != nil {
		return fmt.Errorf("unable to open %s: %w", inPath, err)
	}
	defer func() {
		inFile.Close()
		if err == nil {
			if err = os.Remove(inPath); err != nil {
				err = fmt.Errorf("unable to remove %s: %w", inPath, err)
			}
		}
	}()
	in := bufio.NewScanner(inFile)

	outFile, err := os.Create(outPath)
	if err != nil {
		return fmt.Errorf("unable to create %s: %w", outPath, err)
	}
	defer outFile.Close()
	out := bufio.NewWriter(outFile)
	defer out.Flush()

	out.WriteString(generatedHeader)
	out.WriteString(transfomedHeader)

	return transform(in, out)
}
